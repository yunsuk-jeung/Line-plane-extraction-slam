//    for (int i=0; i < 10; i++){
//        for (int j=0; j<10; j++){
//            if(depth_image[i][j].index < 0){
//                continue;
//            }
//            int num=0;
//
//            for (int ii=interval_image[i][j].up_row; ii <= interval_image[i][j].bottom_row; ii++){
//                for (int jj=interval_image[i][j].left_col; jj <= interval_image[i][j].right_col; jj++){
//                    if(depth_image[ii][jj].index != -1){
//                        num++;
//                    }
//                }
//            }
//            std::cout << i << ' ' << interval_image[i][j].up_row<< ' ' << interval_image[i][j].bottom_row << std::endl;
//            std::cout << j << ' ' << interval_image[i][j].left_col<< ' ' << interval_image[i][j].right_col << std::endl;
//            std::cout << num << std::endl;
//
//        }
//    }


}
//void image::create_interval_image(const spherical_point (&depth_image)[ROW][COL]) {
//    interval_point ver;
//    interval_point hor;
//    interval_point input_interval_point;
//    float input_depth;
//    float pre_depth;
//    int left_col;
//    int right_col;
//    int up_row;
//    int bottom_row;
//
//    for( int i=0 ; i< ROW; i ++){
//        for (int j=0; j<COL; j++ ){
//            if(depth_image[i][j].index != -1){
//                left_col=0;
//                right_col =4999;
//                pre_depth=depth_image[i][j].r;
//                ver = check_vertical(i,j,depth_image,boundary_row);
//                up_row = ver.up_row;
//                bottom_row = ver.bottom_row;
//                for (int ii = i; ii >= up_row; ii--){
//                    if (depth_image[ii][j].index == -1){
//                        input_depth = pre_depth;
//                    }else{
//                        input_depth = depth_image[ii][j].r;
//                        pre_depth = input_depth;
//                    }
//                    hor = check_horizontal(ii,j,depth_image,boundary_col,input_depth);
//                    if(left_col < hor.left_col){
//                        left_col = hor.left_col;
//                    }
//                    if(right_col > hor.left_col){
//                        right_col = hor.right_col;
//                    }
//                }
//                for (int ii = i; ii <= bottom_row; ii++){
//                    if (depth_image[ii][j].index == -1){
//                        input_depth = pre_depth;
//                    }else{
//                        input_depth = depth_image[ii][j].r;
//                        pre_depth = input_depth;
//                    }
//                    hor = check_horizontal(ii,j,depth_image,boundary_col,input_depth);
//                    if(left_col < hor.left_col){
//                        left_col = hor.left_col;
//                    }
//                    if(right_col > hor.right_col){
//                        right_col = hor.right_col;
//                    }
//                }
//                input_interval_point.up_row = up_row;
//                input_interval_point.bottom_row = bottom_row;
//                input_interval_point.left_col = left_col;
//                input_interval_point.right_col = right_col;
//                interval_image[i][j] = input_interval_point;
//
////                std::cout << interval_image[i][j].right_col << std::endl;
////                std::cout << interval_image[i][j].left_col << std::endl;
////                std::cout <<  interval_image[i][j].up_row<<std::endl;
////                std::cout<<   interval_image[i][j].bottom_row<<std::endl;
////                std::cout << 111 << std::endl;
//            }
//        }
//    }
//
//}
//// get normal with std:;vector<integral_point>
//pcl::PointCloud<pcl::Normal>::Ptr image::get_normal(spherical_point (&depth_image)[ROW][COL], pcl::PointCloud<pcl::PointXYZRGB>::Ptr vertical_cloud) {
//    clock_t begin, end;
//    begin = clock();
//    std::cout << "star_normal" << std:: endl;
//    int left_col;
//    int right_col;
//    int up_row;
//    int bottom_row;
//    int num;
//    interval_point checked;
//    double cxx;
//    double cxy;
//    double cxz;
//    double cyy;
//    double cyz;
//    double czz;
//    double cx;
//    double cy;
//    double cz;
//    double eigen1;
//    double eigen2;
//    double eigen3;
//
//    pcl::Normal point_normal;
//    Eigen::Matrix3f cc;
//    Eigen::Vector3f c;
//    Eigen::Matrix3f cov_matrix;
//
//    for(int i=0; i<ROW; i++) {
//        for (int j=0; j<COL;j++) {
//            if(depth_image[i][j].index != -1) {
//                left_col = interval_image[i][j].left_col + 1;
//                right_col = interval_image[i][j].right_col + 1;
//                up_row = interval_image[i][j].up_row + 1;
//                bottom_row = interval_image[i][j].bottom_row + 1;
//                num = integral_image[bottom_row][right_col].itg_num - integral_image[up_row - 1][right_col].itg_num -
//                      integral_image[bottom_row][left_col - 1].itg_num + integral_image[up_row - 1][left_col - 1].itg_num;
////                if (num > 2 && right_col - left_col > 0 && bottom_row-up_row >0) {
//                if (num > 4 ) {
//
//                    cc(0, 0) = integral_image[bottom_row][right_col].itg_xx - integral_image[up_row - 1][right_col].itg_xx -
//                          integral_image[bottom_row][left_col - 1].itg_xx + integral_image[up_row - 1][left_col - 1].itg_xx;
//
//                    cc(0, 1) = integral_image[bottom_row][right_col].itg_xy - integral_image[up_row - 1][right_col].itg_xy -
//                          integral_image[bottom_row][left_col - 1].itg_xy + integral_image[up_row - 1][left_col - 1].itg_xy;
//
//                    cc(0, 2) = integral_image[bottom_row][right_col].itg_xz - integral_image[up_row - 1][right_col].itg_xz -
//                          integral_image[bottom_row][left_col - 1].itg_xz + integral_image[up_row - 1][left_col - 1].itg_xz;
//
//
//                    cc(1, 1)  = integral_image[bottom_row][right_col].itg_yy - integral_image[up_row - 1][right_col].itg_yy -
//                          integral_image[bottom_row][left_col - 1].itg_yy + integral_image[up_row - 1][left_col - 1].itg_yy;
//
//                    cc(1, 2)  = integral_image[bottom_row][right_col].itg_yz - integral_image[up_row - 1][right_col].itg_yz -
//                          integral_image[bottom_row][left_col - 1].itg_yz + integral_image[up_row - 1][left_col - 1].itg_yz;
//
//
//                    cc(2, 2) = integral_image[bottom_row][right_col].itg_zz - integral_image[up_row - 1][right_col].itg_zz -
//                          integral_image[bottom_row][left_col - 1].itg_zz + integral_image[up_row - 1][left_col - 1].itg_zz;
//                    cc(1, 0) = cc(0,1);
//                    cc(2, 0) = cc(0,2);
//                    cc(2, 1) = cc(1,2);
//
//                    c(0) = integral_image[bottom_row][right_col].itg_x - integral_image[up_row - 1][right_col].itg_x -
//                         integral_image[bottom_row][left_col - 1].itg_x + integral_image[up_row - 1][left_col - 1].itg_x;
//
//                    c(1) = integral_image[bottom_row][right_col].itg_y - integral_image[up_row - 1][right_col].itg_y -
//                         integral_image[bottom_row][left_col - 1].itg_y + integral_image[up_row - 1][left_col - 1].itg_y;
//
//                    c(2) = integral_image[bottom_row][right_col].itg_z - integral_image[up_row - 1][right_col].itg_z -
//                         integral_image[bottom_row][left_col - 1].itg_z + integral_image[up_row - 1][left_col - 1].itg_z;
//
//                    cov_matrix = cc ;
//                    cov_matrix -= c * c.transpose() / num;
//
//                    Eigen::EigenSolver<Eigen::Matrix3f> s(cov_matrix);
////
////
//                    eigen1 = s.eigenvalues().col(0)[0].real();
//                    eigen2 = s.eigenvalues().col(0)[1].real();
//                    eigen3 = s.eigenvalues().col(0)[2].real();
////                    eigen1 = fabs(s.eigenvalues().col(0)[0].real());
////                    eigen2 = fabs(s.eigenvalues().col(0)[1].real());
////                    eigen3 = fabs(s.eigenvalues().col(0)[2].real());
//                    if (eigen1 < eigen2 && eigen1 < eigen3) {
//                        point_normal.normal_x=s.eigenvectors().col(0)[0].real();
//                        point_normal.normal_y = s.eigenvectors().col(0)[1].real();
//                        point_normal.normal_z = s.eigenvectors().col(0)[2].real();
//
//                    } else if (eigen2 < eigen1 && eigen2 < eigen3) {
//                        point_normal.normal_x = s.eigenvectors().col(1)[0].real();
//                        point_normal.normal_y = s.eigenvectors().col(1)[1].real();
//                        point_normal.normal_z = s.eigenvectors().col(1)[2].real();
//
//                    } else if (eigen3 < eigen1 && eigen3 < eigen2){
//                        point_normal.normal_x = s.eigenvectors().col(2)[0].real();
//                        point_normal.normal_y = s.eigenvectors().col(2)[1].real();
//                        point_normal.normal_z = s.eigenvectors().col(2)[2].real();
//                    }else {
//                        point_normal.normal_x =0;
//                        point_normal.normal_y =0;
//                        point_normal.normal_z=0;
//                    }
//                    if(point_normal.normal_x * vertical_cloud->points[depth_image[i][j].index].x+point_normal.normal_y * vertical_cloud->points[depth_image[i][j].index].y+point_normal.normal_z * vertical_cloud->points[depth_image[i][j].index].z > 0){
//                        point_normal.normal_x = -point_normal.normal_x;
//                        point_normal.normal_y = -point_normal.normal_y;
//                        point_normal.normal_z = -point_normal.normal_z;
//                        normals->points.push_back(point_normal);
//                    }else if(point_normal.normal_x * vertical_cloud->points[depth_image[i][j].index].x+point_normal.normal_y * vertical_cloud->points[depth_image[i][j].index].y+point_normal.normal_z * vertical_cloud->points[depth_image[i][j].index].z == 0) {
//                        depth_image[i][j].index = -1;
//                    }else{
//                        normals->points.push_back(point_normal);
//                    }
//
//                }else{
//                    depth_image[i][j].index = -1;
//                }
//            }
//        }
//    }
//    end = clock();
//    std::cout << "end_normal" << std:: endl;
//    std::cout<<"수행시간 : "<<((end-begin))<<std::endl;
//    return normals;
//
//}
